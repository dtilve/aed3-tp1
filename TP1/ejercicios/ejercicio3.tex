\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage[margin=2cm]{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}

\begin{document}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\section{Kamehameha}

\subsection{Descripcion del problema}

El problema consiste en calcular la mínima cantidad de Kamehamehas que debe lanzar Goku para destruir un cunjunto de andriodes usando Backtracking.
Al usar backtracking, el problema se reduce a trazar todas las posibles rectas que pasan una sola vez por cada punto y elegir la combinación con menor cantidad de rectas. Por ejemplo, si hay 5 androides en las siguientes posiciones
1 (1,2) 2 (2,1) 3 (3,2) 4 (4,2) 5 (3,3)
Como muestra el siguiente gráfico
\begin{figure}[h!]
  \centering
  \includegraphics[width=7cm, height=6cm]{ejemploHame1}
  \caption{Puntos distribuidos inicialmente.}
\end{figure}

Una posible solución óptima sería lanzar 2 Kamehameha, 1 que mate a 3 androides (al 1, 3 y 4), la recta verde, y otro que mate a los otros 2, la recta azul.

\subsection{Descripción de la resolución}
La idea del algoritmo es que recursivamente vaya creando todas las combinaciones de rectas. Esto lo logramos utilizando una función principal, Kamehameha, a la que recurrimos y 2 funciones, una que se fija si un androide puede ser atacado con un Kamehameha ya lanzado (si esta alineado con algun con algun otro grupo de androides ya atacados) y vuelve a llamar a la función principal con los nuevos valores una vez por cada grupo con el que esta alineado este androide y otra función que comienza un nuevo ataque con ese androide y vuelve a llamar a la función principal. De esta forma, probando con un enemigo, volviendo atras, probando con el siguiente, volviendo atras y asi sucesivamente hasta probar con todos los enemigos, podemos generar todas las posibles combinaciones de líneas. Lo único que resta es verificar cual de estas es la óptima. Para conseguirlo, cada vez que generamos una solución completa, verificamos su tamaño (su acantidad de líneas) y la guardamos si es la menor hasta el momento, sino la descartamos.
Para mejorar el tiempo de ejecución decidimos agregar un a poda que descarta soluciones que estan siendo generadas en el momento que su tamaño supera el tamaño de la solución minima alamacenada, ya que sabemos que si o si es mayor o igual a la que ya tenemos, por lo tanto no nos sirve.

\subsection{Cota de complejidad}
Sabemos que la cantidad de posibles soluciones para una entrada de $n$ androides es $n!$ ya que es la cantidad de posibles combinaciones de androides. Por lo tanto, la cantidad de hojas de nuestro árbol de recursión, es decir la cantidad de soluciones posibles, esta acotada por $n!$ ya que no se llega a la misma solución más de una vez.

Por como planteamos la resolución del poroblema, por cada solución que generamos, volvemos atras y reutilizamos lo ya calculado para generar todas las posibles, de esta forma el árbol las hojas hojas de nuestro árbol tienen siempre al menos un hermano. Suponiendo el peor caso, donde cada hoja tiene solamente un hermano, como cada sub solución es una solucion posible de un problema de menor tamaño, podemos asumir que todo nodo tiene soloamente un hermano, convirtiendo a nuestro árbol de recursión en un árbol binario. Teniendo $n!$ hojas y siendo la cantidad total de nodos $= (($\#$hojas)*2 - 1)$ nos da que la cantidad de nodos es del orden de $2*n!$ por lo tanto la complejidad del algoritmo termina siendo $\mathcal{O}(n!)$.

\subsection{Pseudocódigo}

\begin{algorithm}
\caption{Kamehameha}
\begin{algorithmic}
  \Function{Kamehameha}{$enemigos$: listaPos, $ataques$: Kamehamehas, $nroAtaque$: int} 
	\If{$minimoGlobal$ $\leq$ size($ataques$)} \Comment $\mathcal{O}(1)$
		\State return \Comment $\mathcal{O}(1)$
	\EndIf
	\If{size($enemigos$) $=$ $0$)} \Comment $\mathcal{O}(1)$
		\If{$minimoGlobal$ $>$ size($ataques$)}\Comment $\mathcal{O}(1)$
			\State $minimoGlobal \gets$ size($ataques$) \Comment $\mathcal{O}(1)$ 		
			\State $mejorConfiguracion \gets ataques$ \Comment $\mathcal{O}(1)$
		\EndIf
	\Else
		\State $enemigo \gets enemigos[0]$ \Comment $\mathcal{O}(1)$
		\State erase($enemigo$, $enemigos$) \Comment $\mathcal{O}($size($enemigos$))
		\State AtacarEnAtacados($enemigo$, $enemigos$, $ataques$, $nroAtaques$)	\Comment $\mathcal{O}(nroAtaques)$
		\State AtacarEnNuevoAtaque($enemigo$, $enemigos$, $ataques$, $nroAtaques$) \Comment $\mathcal{O}(1)$
		\State insert($enemigo$, $enemigos$) \Comment $\mathcal{O}($size($enemigos$))
\EndIf
\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(n!)$\\
    
\end{algorithm}

\begin{algorithm}
\caption{AtacarEnAtacados}
\begin{algorithmic}
  \Function{AtacarEnAtacados}{$enemigo$: posicion, $restoEnemigos$: listaPos, $ataques$: Kamehamehas, $nroAtaque$: int}
\State $i \gets 0$ \Comment $\mathcal{O}(1)$
\While{$i \leq nroAtque$} \Comment $\mathcal{O}(nroAtaques)$
	\State $atacados \gets ataques[i]$ \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
	\If{size($atacados$) $=$ $0$} \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State $comenzarAtaque \gets $nuevaListaPos() \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State pushBack($enemigo, comenzarAtque$) \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State $ataque[i] \gets 	comenzarAtaque$ \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State Kamehameha($restoEnemigos$, $ataques$, $nroAtaques$) \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State $restablecerAtaque \gets $nuevaListaPos() \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State $ataque[i] \gets 	restablecerAtaque$ \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
	\ElsIf{Alineados($atacados$, $enemigo$)} \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State pushBack($enemigo$, $ataque[i]$) \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State Kamehameha($restoEnemigos$, $ataques$, $nroAtaques$) \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
		\State popBack($ataque[i]$) \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
	\EndIf
	\State $i \gets i + 1$ \Comment $\mathcal{O}(1) * \mathcal{O}(nroAtaques)$
\EndWhile
\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(nroAtaques)$\\
    
\end{algorithm}
 \newpage

\begin{algorithm}
\caption{AtacarEnNuevoAtaque}
\begin{algorithmic}
  \Function{AtacarEnNuevoAtaque}{$enemigo$: posicion, $restoEnemigos$: listaPos, $ataques$: Kamehamehas, $nroAtaque$: int}

\If{size($ataque[nroAtaque]$) $>$ $0$} \Comment $\mathcal{O}(1)$
	\State $comenzarAtaque \gets $nuevaListaPos() \Comment $\mathcal{O}(1)$
	\State pushBack($enemigo, comenzarAtque$) \Comment $\mathcal{O}(1)$
	\State pushBack($comenzarAtaque, ataques$) \Comment $\mathcal{O}(1)$
	\State $nroAtaque \gets nroAtaque + 1$ \Comment $\mathcal{O}(1)$
	\State Kamehameha($restoEnemigos$, $ataques$, $nroAtaques$) \Comment $\mathcal{O}(1)$
	\State $nroAtaque \gets 	nroAtaque - 1$ \Comment $\mathcal{O}(1)$
	\State popBack($ataque$) \Comment $\mathcal{O}(1)$
\EndIf

\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(1)$\\
\end{algorithm}

\begin{algorithm}
\caption{Alineados}
\begin{algorithmic}
  \Function{Alineados}{$atacados$: kamehameha, $enemigo$: posicion}{Bool} 
  	\If{size($atacados$) $\leq$ $1$} \Comment $\mathcal{O}(1)$
  		\State return $true$ \Comment $\mathcal{O}(1)$
  	\Else
  		\State $primero \gets atacados[0]$ \Comment $\mathcal{O}(1)$
  		\State $segundo \gets atacados[1]$ \Comment $\mathcal{O}(1)$
  		\State $termino1 \gets segundo[1] - primero[1]$ \Comment $\mathcal{O}(1)$
  		\State $termino2 \gets enemigo[0] - primero[0]$ \Comment $\mathcal{O}(1)$
    		\State $termino3 \gets enemigo[1] - primero[1]$ \Comment $\mathcal{O}(1)$
      	\State $termino4 \gets segundo[0] - primero[0]$ \Comment $\mathcal{O}(1)$
      	\State return $termino1*termino2 = termino3*termino4$ \Comment $\mathcal{O}(1)$ 
  	\EndIf
\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(1)$\\
\end{algorithm}



\subsection{Extracto importante de código}
\begin{lstlisting}
typedef pair<int,int> posicion_t;
typedef vector<posicion_t> Kamehameha_t;
typedef vector<Kamehameha_t> Kamehamehas_t;
typedef deque<posicion_t> listaPos_t;

int minimo_global = std::numeric_limits<int>::max();
listaPos_t enemigos_global;
Kamehamehas_t mejor_configuracion;

void Kamehameha(listaPos_t enemigos,
                Kamehamehas_t enLaMira,
                int indexRectaActual);
void atacarEnAtaqueActual(posicion_t enemigo,
                          listaPos_t restoEnemigos,
                          Kamehamehas_t ataques,
                          int nroAtaque);
void atacarEnNuevoAtaque(posicion_t enemigo,
                         listaPos_t restoEnemigos,
                         Kamehamehas_t ataques,
                         int nroAtaque);
bool alineados (Kamehameha_t atacados, posicion_t enemigo);
void reporte(listaPos_t enemigos, Kamehamehas_t ataques, int nroAtaque);
int buscarPosicion(const posicion_t& enemigo);
void mostrarSolucion();

int main() {
    int cantEnemigos;
    cin >> cantEnemigos;
    listaPos_t enemigos;
    Kamehamehas_t enLaMira;
    Kamehameha_t kamehameha;
    enLaMira.push_back(kamehameha);
    int indexRectaActual;
	posicion_t posicion;
    srand(time(NULL));
    for (int i = 0; i < cantEnemigos; i++) {
        int x = rand() %10;
        int y = rand() %10;
    	posicion = make_pair(x, y);
    	enemigos.push_back((posicion));
    }
    //Para imprimir las tuplas generadas al azar:
    enemigos_global = enemigos;
    for (listaPos_t::iterator it = enemigos.begin(); it != enemigos.end(); ++it) {
            cout << (*it).first << " " << (*it).second << endl;
    }
    Kamehameha(enemigos, enLaMira, 0);
    mostrarSolucion();
    return 0;
}

void Kamehameha(listaPos_t enemigos, Kamehamehas_t ataques, int nroAtaque) {
    if (enemigos.size() == 0) {
        if (minimo_global > (int)ataques.size()) {
            minimo_global = (int) ataques.size();
            mejor_configuracion = ataques;
        }
    } else {
        for (int i = 0; i < enemigos.size(); i++) {
            posicion_t enemigo = enemigos.front();
            enemigos.pop_front();
            atacarEnAtaqueActual(enemigo, enemigos, ataques, nroAtaque);
            atacarEnNuevoAtaque(enemigo, enemigos, ataques, nroAtaque);
            enemigos.push_front(enemigo);
        }
    }
}

void atacarEnAtaqueActual(posicion_t enemigo, listaPos_t restoEnemigos, Kamehamehas_t ataques, int nroAtaque) {
    Kamehameha_t atacados = ataques[nroAtaque];
    if (atacados.size() == 0){
        Kamehameha_t comenzarAtaque;
        comenzarAtaque.push_back(enemigo);
        ataques[nroAtaque] = comenzarAtaque;
        Kamehameha(restoEnemigos, ataques, nroAtaque);
        Kamehameha_t reestablecerAtaque;
        ataques[nroAtaque] = reestablecerAtaque;
    } else if (alineados(atacados, enemigo)) {
        ataques[nroAtaque].push_back(enemigo);
        Kamehameha(restoEnemigos, ataques, nroAtaque);
        ataques[nroAtaque].pop_back();
    } else {
        return;
    }
}

void atacarEnNuevoAtaque(posicion_t enemigo, listaPos_t restoEnemigos, Kamehamehas_t ataques, int nroAtaque) {
    if (ataques[nroAtaque].size() > 0) {
        Kamehameha_t comenzarAtaque;
        comenzarAtaque.push_back(enemigo);
        ataques.push_back(comenzarAtaque);
        nroAtaque++;
        Kamehameha(restoEnemigos, ataques, nroAtaque);
        nroAtaque--;
        ataques.pop_back();
    }
}

bool alineados (Kamehameha_t atacados, posicion_t enemigo) {
    if (atacados.size() == 0 || atacados.size() == 1) {
        return true;
    } else {
        posicion_t primero = atacados[0];
        posicion_t segundo = atacados[1];
        int termino1 = segundo.second - primero.second;
        int termino2 = enemigo.first - primero.first;
        int termino3 = enemigo.second - primero.second;
        int termino4 = segundo.first - primero.first;
        return termino1*termino2 == termino3*termino4;
    }
}

void reporte(listaPos_t enemigos, Kamehamehas_t ataques, int nroAtaque) {
    cout << "enemigos: ";
    for (listaPos_t::iterator itL = enemigos.begin(); itL != enemigos.end(); ++itL) {
        cout << "(" << (*itL).first << ", " << (*itL).second << ")";
        if (itL!= enemigos.end()) {
            cout << ", ";
        }
    }
    cout << endl ;
    for (int i = 0; i < ataques.size(); i++) {
        Kamehameha_t ataqueEnIdx = ataques[i];
        cout << "[";
        for (Kamehameha_t::iterator it = ataqueEnIdx.begin(); it != ataqueEnIdx.end(); ++it) {
            cout << "(" << (*it).first << ", " << (*it).second << "), ";
            if (it!= ataqueEnIdx.end()){ cout << ", "; };
        }
        cout << "]" << endl;
    }
}

void mostrarSolucion() {
    cout << mejor_configuracion.size() << endl;
    for (int i = 0; i < mejor_configuracion.size(); i++) {
        Kamehameha_t ataqueEnIdx = mejor_configuracion[i];
        cout << ataqueEnIdx.size() << " ";
        for (Kamehameha_t::iterator it = ataqueEnIdx.begin(); it != ataqueEnIdx.end(); ++it) {
            cout << (buscarPosicion(*it)+1) << " ";
        }
        cout << endl;
    }
}

int buscarPosicion(const posicion_t& enemigo) {
    listaPos_t::iterator it = find (enemigos_global.begin(), enemigos_global.end(), enemigo);
    return distance(enemigos_global.begin(), it);
}
\end{lstlisting}

\subsection{Experimentacion}
\begin{verbatim}
Se puede observar que el tiempo que tarda el algoritmo es relativo a la distribucion de los puntos, aunque principalmente a la cantidad que sean. A partir de 16 puntos el algoritmo tarda mas de un minuto.

Cantidad de puntos = 1
Posiciones = 9 8
El tiempo que tardo es:1.7e-05
Rectas que necesitamos = 1
1 1 

Cantidad de puntos = 2
Posiciones = 12 5 - 9 3
El tiempo que tardo es:3.2e-05
Rectas que necesitamos = 1
2 1 2 
   
Cantidad de puntos = 3
Posiciones = 6 3 - 14 7 - 3 12
El tiempo que tardo es:4.4e-05
Rectas que necesitamos = 2
2 1 2 
1 3 
   
Cantidad de puntos = 4
Posiciones = 13 0 - 1 12 - 9 10 - 10 1
El tiempo que tardo es:6e-05
Rectas que necesitamos = 2
2 1 2 
2 3 4 
   
Cantidad de puntos = 5
Posiciones = 9 0 - 11 6 - 14 12 - 12 8 - 5 9
El tiempo que tardo es:0.000175
Rectas que necesitamos = 2
2 1 5 
3 2 3 4 
   
Cantidad de puntos = 6
Posiciones = 5 4 - 0 11 - 1 7 - 3 9 - 10 10 - 12 3
El tiempo que tardo es:0.000169
Rectas que necesitamos = 3
2 1 2 
2 3 4 
2 5 6 
   
Cantidad de puntos = 7
Posiciones = 12 9 - 7 13 - 5 10 - 10 14 - 9 7 - 0 3 - 11 8
El tiempo que tardo es:0.000836
Rectas que necesitamos = 4
2 1 2 
2 3 4 
2 5 6 
1 7 
   
Cantidad de puntos = 8
Posiciones = 6 13 - 7 3 - 1 0 - 4 10 - 8 6 - 3 9 - 0 5 - 12 2
El tiempo que tardo es:0.00056
Rectas que necesitamos = 3
3 1 6 7 
2 2 3 
3 4 5 8 
   
Cantidad de puntos = 9
Posiciones = 7 11 - 12 2 - 8 0 - 0 3 - 13 12 - 6 5 - 1 7 - 3 6 - 9 1
El tiempo que tardo es:0.006745
Rectas que necesitamos = 5
2 1 2 
2 3 4 
2 5 6 
2 7 8 
1 9 
   
Cantidad de puntos = 10
Posiciones = 6 9 - 4 12 - 2 14 - 8 7 - 3 3 - 9 10 - 5 4 - 11 6 - 10 13 - 14 2
El tiempo que tardo es:0.002715
Rectas que necesitamos = 4
2 1 5 
3 2 3 10 
3 4 6 9 
2 7 8 
   
Cantidad de puntos = 15
Posiciones = 0 2 - 5 5 - 14 8 - 3 13 - 9 4 - 7 14 - 8 12 - 12 1 - 10 11 - 6 3 - 4 9 - 13 7 - 11 6 - 2 0 - 1 10
El tiempo que tardo es:0.785094
Rectas que necesitamos = 7
2 1 2 
2 3 4 
2 5 6 
2 7 10 
3 8 9 13 
2 11 12 
2 14 15 

Gafico que representa este experimento:

\end{verbatim}

\end{document}
