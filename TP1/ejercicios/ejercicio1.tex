\documentclass[10pt,a4paper]{article}
\usepackage[utf8]{inputenc} % para poder usar tildes en archivos UTF-8
\usepackage[spanish]{babel} % para que comandos como \today den el resultado en castellano
\usepackage[margin=2.5cm]{geometry}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}


\begin{document}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}
\lstset{frame=tb,
  language=Java,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}

\section{Kaio Ken}

\subsection{Descripcion del problema}
\begin{verbatim}
El problema se trata de analizar la cantidad de peleas que debe haber entre un grupo de
guerreros, si en cada pelea hay dos bandos a los que pueden pertenecer, para que todos
peleen con todos y en cada pelea esten en uno de los dos bandos. Matemáticamente lo que
proponemos para resolver en problema es: un conjunto, que se divide en dos una cantidad
finita de veces tal que todos los elementos hallan estado en el conjunto opuesto a todos
los demás elementos en elgun momento.
	Observamos que la cantidad de peleas es logarítmica respecto a la cantidad de guerreros
o elementos del conjunto principal: si n es potencia de 2 en log_2(n) y si n no es
potencia de 2 en parte entera(log_2(n))+1. Esto es porque en la primer pelea, si
establecemos que n/2 elementos pertenecen al bando 1 y n/2 elementos pertenecen al bando
2, ya tenemos que cada elemento peleo con la mitad del conjunto. Podemos observar que
resta que cada elemento pelee contra sus compañeros de equipo actual. Por lo que,
repetimos el paso anterior para cada conjunto de n/2 elementos. Y así vamos a obtener en
log_2(n) peleas, que cada elemento pelea con todos los demás, porque el conjunto de n
elementos se “divide” en dos cada vez; decimos “divide” porque los equipos son dos
siempre: bando 1 y bando dos, pero uso la expresión para explicar cómo obtenemos el
resultado que todos peleen con todos. 
	Debemos notar que si la cantidad de elementos es potencia de 2, la cantidad de peleas es
exactamente el logaritmo en base 2 de n. Pero si n no es potencia de 2, voy a necesitar
una pelea más para que todos los elementos completen las peleas, es decir que todos
terminen de pelear. Esto sucede porque la cantidad de elementos se encuentra entre 2
potencias de 2 (el. Entre 16=2^n y 32=2^(n+1)) cualesquiera, por lo tanto, las peleas
anteriores dividieron a los grupos n veces, quedan menos de la mitad de elementos pelear
con la anterior mitad.
\end{verbatim}
	 


\subsection{Pseudocódigo}
\begin{verbatim}
Datos de entrada: n.
Generamos una matriz M de n * (log(n)+1) posiciones.
En un ciclo que itera i de 0 a log(n) inclusive:
	En un ciclo que itera j de 0 a n-1 inclusive:
		Para la iteracion i asignamos M(i,j) grupo 1 y dos alternadamente a las posiciones,
cambiando de grupo cada 2^i casillas.
Imprimimos i. Luego, imprimimos la matriz.
\end{verbatim}



\begin{algorithm}
\caption{inicializarMatriz}
\begin{algorithmic}
  \Function{InicializarMatriz}{filas: int, columnas: int, matriz: $Arreglo<Arreglo<int>>$}
	\For{$h \leftarrow 0~..~filas-1$} \Comment $\mathcal{O}(filas)$
		\For{$q \leftarrow 0~..~columnas-1$} \Comment $\mathcal{O}(columnas)$
		\State matriz[h][q] = 0 \Comment $\mathcal{O}(1)$
		\EndFor
	\EndFor

\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(filas*columnas)$\\
    \underline{Justificación:} Hay dos ciclos anidados.
\end{algorithm}


\begin{algorithm}
\caption{distribuirGuerreros}
\begin{algorithmic}
  \Function{DistribuirGuerreros}{filas: int, columnas: int, matriz: $Arreglo<Arreglo<int>>$ }
	\State int $i \gets 0$ \Comment $\mathcal{O}(1)$
	\State int j \Comment $\mathcal{O}(1)$
	\State int $cambio \gets 0$ \Comment $\mathcal{O}(1)$
	\State int $equipo \gets 1$ \Comment $\mathcal{O}(1)$
	\State int $x \gets 0$ \Comment $\mathcal{O}(1)$
	\While{$i < filas$} \Comment $\mathcal{O}(filas)$
		\State $cambio \gets pow(2,i)$ \Comment $\mathcal{O}(1)$
		\State $x \gets 0$ \Comment $\mathcal{O}(1)$
		\State $j \gets 0$ \Comment $\mathcal{O}(1)$
		\While{$j < columnas$} \Comment $\mathcal{O}(columnas)$
			\If{$x < cambio$} \Comment $\mathcal{O}(1)$
				\State $matriz[i][j] \gets equipo$ \Comment $\mathcal{O}(1)$
			\Else
				\State $equipo \gets ((equipo +1) mod 2)$ \Comment $\mathcal{O}(1)$
				\State $matriz[i][j] \gets equipo$ \Comment $\mathcal{O}(1)$
				\State $x \gets 0$ \Comment $\mathcal{O}(1)$
			\EndIf
			\State $j++$ \Comment $\mathcal{O}(1)$
			\State $x++$ \Comment $\mathcal{O}(1)$
		\EndWhile
		\State $i++$ \Comment $\mathcal{O}(1)$
	\EndWhile
\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(filas*columnas)$\\
\end{algorithm}


\begin{algorithm}
\caption{KaioKen}
\begin{algorithmic}
  \Function{Kaioken}{n: int}
	\State int $filas \gets \ceil*{\log_2 n}$ \Comment $\mathcal{O}(1)$
	\State int m[filas][n] \Comment $\mathcal{O}(1)$
	\State inicializarMatriz(filas, n, m) \Comment $\mathcal{O}(filas*n) = \mathcal{O}(\ceil*{\log_2 n}*n)$
	\State distribuirGuerreros(filas, n, m) \Comment $\mathcal{O}(filas*n) = \mathcal{O}(\ceil*{\log_2 n}*n)$
	\\
	\State int $i \gets 0$ \Comment $\mathcal{O}(1)$
	\State int j \Comment $\mathcal{O}(1)$
	\\
	\State $cout << filas << endl$ \Comment $\mathcal{O}(1)$
	\While{$i < filas$} \Comment $\mathcal{O}(filas) = \mathcal{O}(\ceil*{\log_2 n})$
		\State $j \gets 0$ \Comment $\mathcal{O}(1)$
		\While{$j < n$} \Comment $\mathcal{O}(n)$
			\State $cout << m[i][j]+1$ \Comment $\mathcal{O}(1)$
			\State $j++$ \Comment $\mathcal{O}(1)$
			\If{$j < n$} \Comment $\mathcal{O}(1)$
				\State $std::cout << " "$ \Comment $\mathcal{O}(1)$
			\EndIf
		\EndWhile
		\State $cout << endl$ \Comment $\mathcal{O}(1)$
		\State $i++$ \Comment $\mathcal{O}(1)$
	\EndWhile
\EndFunction
\end{algorithmic}
\underline{Complejidad:} $\mathcal{O}(\log _{2} n * n)$\\
    \underline{Justificación:} $ 2 * \mathcal{O}(\ceil*{\log_2 n}*n)$ + $ \ceil*{\log_2 n} * \mathcal{O}(n)$ = $3*\mathcal{O}(\log _{2} n * n)$ = $\mathcal{O}(\log _{2} n * n)$\\
\end{algorithm}


\newpage
\subsection{Cota de complejidad}
\begin{verbatim}
Como está detallado en el Algoritmo 3, la complejidad del algoritmo propuesto para KaioKen
resulta
\end{verbatim}
$\mathcal{O}(\log _{2} n * n)$\\

\subsection{Experimentacion}
\begin{verbatim}
%ya esta hecha
\end{verbatim}


%lo dejo aca un poco

%\paragraph{ Idea: cada vez que se resuelve una pelea entre grupos, si la misma se da entre dos mitades, ya se consigue que la mitad de los luchadores hayan peleado entre si, quedando pendiente dentro del mismo grupo.}

%\begin{verbatim}
%p <- 1

%kaioKen (N: int){
%	kaioKenGeneralizada(N,1)
%}

%kaioKenGeneralizada (N: int, P: int) {
%	for (N)
%		B (P, N)
%	endfor
%	p += 1
%	if (N != 1 v 2)		
%		kaioKenGeneralizada(ceil(n/2), p)
%		kaioKenGeneralizada(floor(n/2), p)
%	endif	
%}
%\end{verbatim}


\newpage

\subsection{Apéndice: código de KaioKen}
\begin{lstlisting}
#include <math.h>
#include <stdlib.h>
#include <iostream>
using namespace std;

void kaioKen(int);

int main(int argc, char* argv[]){
	int i;
	cin >> i;
	kaioKen(i);
	return 0;
}

void kaioKen(int n){
	int filas = ceil(log2(n));
	int equipo = 1;
	int cambio = 0;
	int x = 0;
	int m [filas][n];
	//Inicializamos la matriz en 0
	for (int h = 0; h < filas; ++h)
	{
		for (int q = 0; q < n; ++q)
		{
			m[h][q] = 0;
		}
	}
	//Distribuimos los guerreros
	for (int i = 0; i < filas; i++){
		cambio = pow(2,i);
		x = 0;
		for(int j = 0; j < n; j++){
			if(x < cambio){
				m[i][j] = equipo;
			}else{
				equipo = ((equipo +1) % 2);
				m[i][j] = equipo;
				x = 0;
			}
			x++;
		}
	}

	cout << filas << endl;
	for(int i = 0; i < filas; i++){
		for(int j = 0; j < n; j++){
			cout << m[i][j]+1;
			if (j < n) {
				std::cout << " ";
			}
		}
		cout << endl;
	}
}
\end{lstlisting}

\end{document}